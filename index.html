<html>
  <meta charset="utf-8">
  <link rel="icon" href="data:;base64,=">
<style>

.link {
  fill: none;
  stroke-width: 1.5px;
}

.axis, .node {
  stroke: #000;
  stroke-width: 1.5px;
}

</style>
<body>
<script src="socket.io.js"></script>
<script src="three.min.js"></script>
<script src="DragControls.js"></script>
<script src="OrbitControls.js"></script>
<script src="TransformControls.js"></script>
<script>

		
var container;
var camera, scene, renderer;
var positions = [];

var structure = new THREE.BoxGeometry( 20, 20, 20 );

init();
animate();

function init() {
    container = document.createElement( 'div' );
    document.body.appendChild( container );
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.z = 1000;
    scene.add( camera );

    scene.add( new THREE.AmbientLight( 0xf0f0f0 ) );
    var light = new THREE.SpotLight( 0xffffff, 1.5 );
    light.position.set( 0, 1500, 200 );
    light.castShadow = true;
    light.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 70, 1, 200, 2000 ) );
    light.shadow.bias = -0.000222;
    light.shadow.mapSize.width = 1024;
    light.shadow.mapSize.height = 1024;
    scene.add( light );
    spotlight = light;

    // scene.add( new THREE.CameraHelper( light.shadow.camera ) );

    var planeGeometry = new THREE.PlaneGeometry( 2000, 2000 );
    planeGeometry.rotateX( - Math.PI / 2 );
    var planeMaterial = new THREE.ShadowMaterial();
    planeMaterial.opacity = 0.2;

    var plane = new THREE.Mesh( planeGeometry, planeMaterial );
    plane.position.y = -200;
    plane.receiveShadow = true;
    scene.add( plane );

    var helper = new THREE.GridHelper( 2000, 100 );
    helper.position.y = - 199;
    helper.material.opacity = 0.25;
    helper.material.transparent = true;
    scene.add( helper );

    var axis = new THREE.AxisHelper();
    axis.position.set( -500, -500, -500 );
    scene.add( axis );

    
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setClearColor( 0xf0f0f0 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMap.enabled = true;
    container.appendChild( renderer.domElement );

    // Controls
    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.damping = 0.2;
    controls.addEventListener( 'change', render );

    transformControl = new THREE.TransformControls( camera, renderer.domElement );
    transformControl.addEventListener( 'change', render );
    scene.add( transformControl );

    var material = new THREE.SpriteMaterial( {
	color: 0xff00ff,
	program: function ( context ) {
	    console.log("context");
	    context.beginPath();
	    context.arc( 0, 0, 0.5, 0, PI2, true );
	    context.fill();
	}
    });
    
    var structure = new THREE.Geometry();

    particle = new THREE.Sprite(material);
    particle.position.set(50,50,90);
    scene.add(particle);

    console.log(scene);
    console.log(particle.position);

    structure.vertices.push(particle.position);

    var curve = new THREE.CatmullRomCurve3(positions);
    curve.type = 'catmullrom';
    var line = new THREE.Line( structure, new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.5, linewidth: 2 } ) );
    scene.add(line);
    
    // Hiding transform situation is a little in a mess :()
    transformControl.addEventListener('change',function(e){
	cancelHideTransorm();
    });
    transformControl.addEventListener( 'mouseDown', function( e ) {
	cancelHideTransorm();
    } );
    transformControl.addEventListener( 'mouseUp', function( e ) {
	delayHideTransform();
    } );
    transformControl.addEventListener( 'objectChange', function( e ) {
	updateSplineOutline();
    } );

    var splineHelperObjects = [];
    var dragcontrols = new THREE.DragControls( splineHelperObjects, camera, renderer.domElement ); //
    dragcontrols.enabled = false;
    dragcontrols.addEventListener( 'hoveron', function ( event ) {
	transformControl.attach( event.object );
	cancelHideTransorm();
    } );
    dragcontrols.addEventListener( 'hoveroff', function ( event ) {
	delayHideTransform();
    } );

    controls.addEventListener( 'start', function() {
	cancelHideTransorm();
    } );
    controls.addEventListener( 'end', function() {
	delayHideTransform();
    } );

    var hiding;

    function delayHideTransform() {
	cancelHideTransorm();
	hideTransform();
    }

    function hideTransform() {
	hiding = setTimeout( function() {
	    transformControl.detach( transformControl.object );
	}, 2500 )
    }

    function cancelHideTransorm() {
	if ( hiding ) clearTimeout( hiding );
    }

    addNode();
    var base = addBase(60);
    base.computeLineDistances();
    var object = new THREE.LineSegments(base, new THREE.LineDashedMaterial({ color: 0xffaa00, dashSize: 3, gapSize: 0, lineWidth: 2}));
    scene.add(object);
}

var nodeCount =0;

function addLine(from, to){
    
}

function addBase(size){
    var h = size*0.5;
    var geometry = new THREE.Geometry();

    geometry.vertices.push(
	new THREE.Vector3( -h, -h, -h ),
	new THREE.Vector3( -h, h, -h ),
	new THREE.Vector3( -h, h, -h ),
	new THREE.Vector3( h, h, -h )
    );
    return geometry;
}

function addNode(pos){
    nodeCount++;
    var node = new THREE.Mesh(structure, new THREE.MeshLambertMaterial({
	color: Math.random()* 0xffffffff
    }));
    node.material.ambient = node.material.color;
    if(pos){
	node.position.copy(pos);
    }
    else{
	node.position.x = Math.random()*1000 -500;
	node.position.y = Math.random()*600;
	node.position.z = Math.random()*700 - 400;
    }
    node.castshadow = true;
    node.receiveshadow = true;
    scene.add(node);
    return node;
}

function animate() {
    requestAnimationFrame( animate );
    render();
    controls.update();
    transformControl.update();
}

function render() {
    renderer.render( scene, camera );
}

	</script>
</body>
</html>
