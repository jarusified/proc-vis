<html>
  <meta charset="utf-8">
  <link rel="icon" href="data:;base64,=">
<style>

.link {
  fill: none;
  stroke-width: 1.5px;
}

.axis, .node {
  stroke: #000;
  stroke-width: 1.5px;
}

</style>
<body>
<script src="/socket.io/socket.io.js"></script>
<script src="three.min.js"></script>
<script src="DragControls.js"></script>
<script src="OrbitControls.js"></script>
<script src="TransformControls.js"></script>
<script>

		
var container;
var camera, scene, renderer;
var positions = [];
var lineDistance;
var structure = new THREE.BoxGeometry( 20, 20, 20 );

init();
animate();

function init() {
    container = document.createElement( 'div' );
    document.body.appendChild( container );
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.set( 70, 30, 30 );
    scene.add( camera );

    scene.add( new THREE.AmbientLight( 0x2c9ada ) );
    var light = new THREE.SpotLight( 0xffffff, 1.5 );
    light.position.set( 0, 1500, 200 );
    light.castShadow = true;
    light.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 70, 1, 200, 2000 ) );
    light.shadow.bias = -0.000222;
    light.shadow.mapSize.width = 1024;
    light.shadow.mapSize.height = 1024;
    scene.add( light );
    spotlight = light;

    var planeGeometry = new THREE.PlaneGeometry( 4000, 4000 );
    planeGeometry.rotateX( - Math.PI / 2 );
    var planeMaterial = new THREE.ShadowMaterial();
    planeMaterial.opacity = 0.2;

    var plane = new THREE.Mesh( planeGeometry, planeMaterial );
    plane.position.y = -200;
    plane.receiveShadow = true;
    scene.add( plane );

    var helper = new THREE.GridHelper( 4000, 100 );
    helper.position.y = - 199;
    helper.material.opacity = 0.25;
    helper.material.transparent = true;
    scene.add( helper );

    var axis = new THREE.AxisHelper();
    axis.position.set( -500, -500, -500 );
    scene.add( axis );

    
    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setClearColor( 0xf0f0f0 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.shadowMap.enabled = true;
    container.appendChild( renderer.domElement );

    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.damping = 0.2;
    controls.addEventListener( 'change', render );

    transformControl = new THREE.TransformControls( camera, renderer.domElement );
    transformControl.addEventListener( 'change', render );
    scene.add( transformControl );

    var material = new THREE.SpriteMaterial( {
	color: 0xff00ff,
    });
    
    var structure = new THREE.Geometry();

    particle = new THREE.Sprite(material);
    particle.position.set(50,50,90);
    scene.add(particle);

    structure.vertices.push(particle.position);

    var curve = new THREE.CatmullRomCurve3(positions);
    curve.type = 'catmullrom';
    var line = new THREE.Line( structure, new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.5, linewidth: 2 } ) );
    scene.add(line);
    
    transformControl.addEventListener('change',function(e){
	cancelHideTransorm();
    });
    transformControl.addEventListener( 'mouseDown', function( e ) {
	cancelHideTransorm();
    } );
    transformControl.addEventListener( 'mouseUp', function( e ) {
	delayHideTransform();
    } );
    transformControl.addEventListener( 'objectChange', function( e ) {
	updateSplineOutline();
    } );

    var splineHelperObjects = [];
    var dragcontrols = new THREE.DragControls( splineHelperObjects, camera, renderer.domElement ); //
    dragcontrols.enabled = false;
    dragcontrols.addEventListener( 'hoveron', function ( event ) {
	transformControl.attach( event.object );
	cancelHideTransorm();
    } );
    dragcontrols.addEventListener( 'hoveroff', function ( event ) {
	delayHideTransform();
    } );

    controls.addEventListener( 'start', function() {
	cancelHideTransorm();
    } );
    controls.addEventListener( 'end', function() {
	delayHideTransform();
    } );

    var hiding;
    function delayHideTransform() {
	cancelHideTransorm();
	hideTransform();
    }

    function hideTransform() {
	hiding = setTimeout( function() {
	    transformControl.detach( transformControl.object );
	}, 2500 )
    }

    function cancelHideTransorm() {
	if ( hiding ) clearTimeout( hiding );
    }

//addNode();
    addBase(1000);
    var nodeCount = 0;
    var lines = [];

    var socket = io();
    socket.on('position',function(data){
	process(data);
    });

    function process(data){
	count = 0;
	for(var i=0; i<data.length; i++){
	    if(data.processes[i]["mem_stats"][0]["size"] != undefined && data.processes[i]["mem_stats"][0]["size"] !=0 ){
		console.log(data.processes[i]["argv"].join(" "));
		console.log(data.processes[i]["pid"] +":"+ data.processes[i]["mem_stats"][0]["size"]/1024);
		count++;
		offset = data.processes[i]["mem_stats"][0]["size"]/(1024*1024)*Math.exp(3);;
		addNode(new THREE.Vector3(offset*lineDistance*Math.cos(120), -0.3*offset*lineDistance*Math.cos(120), offset*lineDistance*Math.sin(120)));
	    }
	}
	console.log(count);
    }

    function addLine(from, to, clr){	
	var geometry = new THREE.Geometry();
	geometry.vertices.push(
	    new THREE.Vector3(from.x, from.y, from.z),
	    new THREE.Vector3(to.x, to.y, to.z)
	);
	geometry.computeLineDistances();
	lineDistance = geometry.lineDistances[1];
	var line = new THREE.LineSegments(geometry, new THREE.LineDashedMaterial({ color: clr, gapSize: 0}));
	scene.add(line);
    }
    
    function strtoobj(str){
	var props = str.split(",");
	var obj = {};
	var axis = ["x","y","z"];
	for(var i=0;i<props.length;i++){
	    obj[axis[i]]= parseInt(props[i]);
	}
	return obj;
    }
    
    function addBase(size){
	var h = size*1;
	var users = 3;
	var angle = [];
	for(var i=0;i<users;i++){
	    angle.push(i*(360/users));
	}
	addLine(strtoobj("0, 0, 0"), strtoobj("0,"+h+",0"), 0x000000);
	addLine(strtoobj("0, 0, 0"), strtoobj(-h*Math.cos(angle[0])+","+ -0.3*h+ ","+ -h*Math.sin(angle[0])), 0xff00aa);
	addLine(strtoobj("0, 0, 0"), strtoobj( h*Math.cos(angle[1])+","+ -0.3*h+ ","+  h*Math.sin(angle[1])), 0xaa00ff);
	addLine(strtoobj("0, 0, 0"), strtoobj(-h*Math.cos(angle[2])+","+ -0.3*h+ ","+ -h*Math.sin(angle[2])), 0x00aaff);
    }


    function addNode(pos){
	nodeCount++;
	var sphereGeometry = new THREE.SphereGeometry(2,0,0);
	var node = new THREE.Mesh(sphereGeometry, new THREE.MeshLambertMaterial({
	    color: 0xff0000
	}));
	node.material.ambient = node.material.color;
	if(pos){
	    node.position.copy(pos);
	}
	else{
	    node.position.x = Math.random()*1000 -500;
	    node.position.y = Math.random()*600;
	    node.position.z = Math.random()*700 - 400;
	}
	node.castshadow = true;
	node.receiveshadow = true;
	scene.add(node);
	return node;
    }
    console.log(scene);

}

function animate() {
    requestAnimationFrame( animate );
    render();
    controls.update();
    transformControl.update();
}

function render() {
    renderer.render( scene, camera );
}

</script>
</body>
</html>
