<html>
  <meta charset="utf-8">
  <link rel="icon" href="data:;base64,=">
<style>

.link {
  fill: none;
  stroke-width: 1.5px;
}

.axis, .node {
  stroke: #000;
  stroke-width: 1.5px;
}

</style>
<body>
<script src="socket.io.js"></script>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="hive.js"></script>
<script src="three.min.js"></script>
<script src="DragControls.js"></script>
<script src="OrbitControls.js"></script>
<script src="TransformControls.js"></script>

<script>

var width = window.innerWidth,
    height = window.innerHeight,
    innerRadius = 0,
    outerRadius = window.innerWidth/4,
    numberOfAxis = 4;
var geometry = new THREE.BoxGeometry( 20, 20, 20 );
		   
var scene, camera, renderer;

function init(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, width/height, 1, 10000);
    camera.position.z = 1000;
    scene.add(camera);
    
    scene.add(new THREE.AmbientLight(0xf0f0f0));
    var light = new THREE.SpotLight(0xffffff, 1.5);
    light.position.set(0, 1500, 200);
    light.castShadow = true;
    light.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(70, 1, 200, 2000));
    light.shadow.bias = -0.000222;
    light.shadow.mapSize.width = 1024;
    light.shadow.mapSize.height = 1024;
    spotlight = light;

    var planeGeometry = new THREE.PlaneGeometry(2000, 2000);
    planeGeometry.rotateX( -Math.PI/2);
    var planeMaterial = new THREE.ShadowMaterial();
    planeMaterial.opacity = 0.2;

    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.position.y = -200;
    plane.receiveShadow = true;
    scene.add(plane);

    var helper = new THREE.GridHelper( 2000, 100 );
    helper.position.y = - 199;
    helper.material.opacity = 0.25;
    helper.material.transparent = true;
    scene.add( helper );

    var axis = new THREE.AxisHelper();
    axis.position.set(-500, -500, -500);
    scene.add(axis);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0xf0f0f0);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls( camera, renderer.domElement );
    controls.damping = 0.2;
    controls.addEventListener( 'change', render );
    transformControl = new THREE.TransformControls( camera, renderer.domElement );
    transformControl.addEventListener( 'change', render );
    scene.add( transformControl );

    
    transformControl.addEventListener( 'change', function( e ) {
	cancelHideTransorm();
    } );
    transformControl.addEventListener( 'mouseDown', function( e ) {
	cancelHideTransorm();
    } );
    transformControl.addEventListener( 'mouseUp', function( e ) {
	delayHideTransform();
    } );
    transformControl.addEventListener( 'objectChange', function( e ) {
	updateSplineOutline();
    } );
    var dragcontrols = new THREE.DragControls( camera, renderer.domElement ); //
    dragcontrols.enabled = false;
    dragcontrols.addEventListener( 'hoveron', function ( event ) {
	transformControl.attach( event.object );
	cancelHideTransorm();
    } );
    dragcontrols.addEventListener( 'hoveroff', function ( event ) {
	delayHideTransform();
    } );
    controls.addEventListener( 'start', function() {
	cancelHideTransorm();
    } );
    controls.addEventListener( 'end', function() {
	delayHideTransform();
    } );
}

function render(){
    requestAnimationFrame(render);
    renderer.render(scene, camera);
}

init();
render();

var socket = io.connect(window.location.href);
socket.on("update", function(data){
console.log(data);
});

var angle = d3.scale.ordinal().domain(d3.range(numberOfAxis+1)).rangePoints([0, 2 * Math.PI]),
    radius = d3.scale.linear().range([innerRadius, outerRadius]),
    color = d3.scale.category10().domain(d3.range(20));

console.log(angle);
var nodes = [
  {x: 0, y: .1},
  {x: 0, y: .9},
  {x: 1, y: .2},
  {x: 1, y: .3},
  {x: 2, y: .1},
  {x: 2, y: .8},
  {x: 3, y: .6},
  {x: 3, y: .4}
];

var links = [
  {source: nodes[0], target: nodes[2]},
  {source: nodes[1], target: nodes[3]},
  {source: nodes[2], target: nodes[4]},
  {source: nodes[2], target: nodes[5]},
  {source: nodes[3], target: nodes[5]},
  {source: nodes[4], target: nodes[0]},
  {source: nodes[5], target: nodes[1]}
];

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

svg.selectAll(".axis")
    .data(d3.range(numberOfAxis))
  .enter().append("line")
    .attr("class", "axis")
    .attr("transform", function(d) { return "rotate(" + degrees(angle(d)) + ")"; })
    .attr("x1", radius.range()[0])
    .attr("x2", radius.range()[1]);

svg.selectAll(".link")
    .data(links)
  .enter().append("path")
    .attr("class", "link")
    .attr("d", d3.hive.link()
    .angle(function(d) { return angle(d.x); })
    .radius(function(d) { return radius(d.y); }))
    .style("stroke", function(d) { return color(d.source.x); });

svg.selectAll(".node")
    .data(nodes)
  .enter().append("circle")
    .attr("class", "node")
    .attr("transform", function(d) { return "rotate(" + degrees(angle(d.x)) + ")"; })
    .attr("cx", function(d) { return radius(d.y); })
    .attr("r", 5)
    .style("fill", function(d) { return color(d.x); });

function degrees(radians) {
  return radians / Math.PI * 180 - 90;
}

</script>
